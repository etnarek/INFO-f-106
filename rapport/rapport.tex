\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}

\author{Romain Fontaine\\000377487}
\title{Projet d'année, parie 1 et 2:\\Jeux de dames}
\date{17 décembre 2012}
\begin{document}
\maketitle


\chapter*{Introduction:}
\addcontentsline{toc}{part}{Introduction}
On va créer un jeux de dames avec les règles suivante: \url{http://www.ffjd.fr/Web/} excepté l'obligation de prendre si c'est possible.\\
On va considérer que le terminal du joueur soit en noir ou au moins que les caractères soient en blanc. Le jeux ne pourra pas déterminer les parties infinies du style dame contre dame. C'est pourquoi il sera proposé à l'utilisateur une partie nulle avec son adversaire au cas où.\\
Exemple de damier:\\
\includegraphics[width=0.30\textwidth]{damier.eps}\\


\chapter*{Programme:}
\addcontentsline{toc}{part}{Programme}
\section*{main():}
\addcontentsline{toc}{section}{main()}
Le programme est composé de deux fichiers: draughts.py et draughtsFunctions.py. Le premier s'occupant d'appeler les fonctions du second pour permettre à l'utilisateur de jouer. draughts.py permet aussi la sauvegarde et le chargement d'une parie.\\
la fonction principale permet de demander à l'utilisateur ce qu'il veut faire parmi les possibilités ci-dessous:\\
\includegraphics[width=0.50\textwidth]{menuPrincipal.eps}\\
En fonction de ça sélection on appelle soit la fonction:
\begin{lstlisting}[language=Python]
play(board, player_now)
save(filename, board, player_now)
load(filename)
\end{lstlisting}
La demande de partie nulle est gérée dans la fonction principale comme l'exit.

\section*{load() et save():}
\addcontentsline{toc}{section}{load() et save()}
Les fonctions load() et save() n'ont rien de spécial. Elle charge en mémoire et récupère un damier du type:
\begin{lstlisting}
1
10
 0 -1  0 -1  0 -1  0 -1  0 -1 
-1  0 -1  0 -1  0 -1  0 -1  0 
 0 -1  0 -1  0 -1  0 -1  0 -1 
-1  0 -1  0 -1  0 -1  0 -1  0 
 0  0  0  0  0  0  0  0  0  0 
 0  0  0  0  0  0  0  0  0  0 
 0  1  0  1  0  1  0  1  0  1 
 1  0  1  0  1  0  1  0  1  0 
 0  1  0  1  0  1  0  1  0  1 
 1  0  1  0  1  0  1  0  1  0 
\end{lstlisting}
le format de sauvegarde est ".dat"

\section*{play():}
\addcontentsline{toc}{section}{play()}
La fonction play() fait appel aux différents fonctions contenue dans draughtsFunctions.py de la amnière suivante:
\begin{lstlisting}[language=Python]
while refle_non_finie:
	i,j = input(coordonees du pion a deplacer)
	direction = input(direction)
	length = input(longueur)
	#1 verifier si le mouvement est correct
	checkMove(board, i, j, direction, player_now, length)
	#si c'est correct on bouge le pion:
	movePiece(board, i, j, direction, length)
	#s'il y a une capture on s'en occupe:
	capture(board, i, j)
	#et on transforme la piece en dame si elle est au bout du damier.
	becomeKing(board, i, j)
\end{lstlisting}
Et ce tant que l'utilisateur n'a pas fini sa rafle.\\
Cependant, lors d'une rafle, on ne demande pas les coordonnées de la pièces à bouger vu que c'est celle qui vient de se déplacer.\\
Le plus difficile dans cette fonction est de faire en sorte que, si l'utilisateur rentre des mauvaises coordonnées ou autres, il faut gérer toutes les erreurs possibles (surtout celle qui ne sont pas gérée par checkmove).\\
Une erreur type qu'il aurais pu y avoir est que l'utilisateur rentre une seule coordonnée à la place de deux.

\section*{draugthsFunctions.py:}
\addcontentsline{toc}{section}{draugthsFunctions.py}
Les différentes fonctions de drautsFunction.py servent à créer le damier, l'afficher, déplacer les pièces, vérifier le déplacement et vérifier si on a fini le jeux. Il n'est pas nécessaire de toutes les détailler ici, les fonctions sont assez explicites.


\chapter*{Différence entre partie 1 et 2:}
\addcontentsline{toc}{part}{Différence entre partie 1 et 2}
Les différences entre les deux parties sont: l'ajout de la dame, l'ajout de la prise.\\
Ces différences ont eu comme répercutions:
\begin{enumerate}
\item Ajout d'une fonction qui transforme les pions en dame: becomeKing()
\item move() doit renvoyer les coordonnées de la pièce capturée pour la retirer du damier.
\item Ajout de la fonction capture() permettant de retirer la pièce capturée.
\item checkMove doit renvoyer des messages d'erreurs pour chacune des nouvelles situations possibles.
\item printBoard() doit pouvoir afficher les dames
\item Ajout de la fonction contFree permettant de savoir quelle est la plus longue distance possible sans devoir capturer
\item Ajout de la fonction strerr() transformant un message d'erreur en message lisible pour l'utilisateur
\item Modification de checkEndOfGame() qui doit, en plus de vérifier si un pion ne peut bouger dans les nouvelles condition, vérifier si l'adversaire n'a plus de pion, auquel cas il a perdu.
\end{enumerate}
Seul la fonction initBoard() est restée inchangé. Elle permettait de créer un damier de la dimension voulue avec les pions déjà installés.

\chapter*{Exemple d'utilisation:}
\addcontentsline{toc}{part}{Exemple d'utilisation}
Je viens de jouer un coup pour les blancs et un coup pour les noirs.\\
\includegraphics[width=0.50\textwidth]{jeux1.eps}\\
Après quelque coups, les blancs mangent un pion noir:\\
\includegraphics[width=0.50\textwidth]{rafle.eps}\\
Comme on peut le voir, dès qu'on mange un pion, on passe en mode rafle et il faut taper "Q" pour le quitter. De plus, il ne redemande pas la position de la pièce en mode rafle.


\chapter*{Conclusion:}
\addcontentsline{toc}{part}{Conclusion}
Nous avons maintenant un jeux de dame tout à fait opérationnel en ligne de commande.\\
Il n'est pas toujours facile de rajouter l'une ou l'autre petite règle car, parfois les changements à faire sont dans tout le programme. Parfois, il est même plus pratique de réécrire la fonction puisque la modifier ferait beaucoup de chipotage et pourrait compliquer davantage le code.\\

\tableofcontents
\end{document}